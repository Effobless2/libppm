var N=null,E="",T="t",U="u",searchIndex={};
var R=["testdescandfn","median","std_dev","std_dev_pct","median_abs_dev","median_abs_dev_pct","quartiles","bencher","benchsamples","summary","to_owned","clone_into","try_from","try_into","result","borrow_mut","type_id","borrow","typeid","bencher::stats","testopts","testdesc","formatter","TestDesc","TestPaths","TestDescAndFn","TestOpts","TDynBenchFn","BenchSamples","big_project","grayscale","big_project::pixel::pixel","big_project::image::image"];
searchIndex["bencher"]={"doc":"Simplified stable-compatible benchmark runner.","i":[[3,"Bencher",R[7],"Manager of the benchmarking runs.",N,N],[12,"bytes",E,E,0,N],[3,R[23],E,E,N,N],[12,"name",E,E,1,N],[12,"ignore",E,E,1,N],[3,R[24],E,E,N,N],[12,"file",E,E,2,N],[12,"base",E,E,2,N],[12,"relative_dir",E,E,2,N],[3,R[25],E,E,N,N],[12,"desc",E,E,3,N],[12,"testfn",E,E,3,N],[3,R[26],E,E,N,N],[12,"filter",E,E,4,N],[12,"run_ignored",E,E,4,N],[12,"logfile",E,E,4,N],[12,"quiet",E,E,4,N],[12,"test_threads",E,E,4,N],[3,R[28],E,E,N,N],[4,"TestFn",E,E,N,N],[13,"StaticBenchFn",E,E,5,N],[13,"DynBenchFn",E,E,5,N],[5,"fmt_bench_samples",E,E,N,[[[R[8]]],["string"]]],[5,"run_tests_console",E,E,N,[[[R[20]],[R[0]],["vec",[R[0]]]],[[R[14],["bool"]],["bool"]]]],[5,"black_box",E,"NOTE: We don't have a proper black box in stable Rust.…",N,[[[T]],[T]]],[0,"stats",E,E,N,N],[3,"Summary",R[19],"Extracted collection of all the summary statistics of a…",N,N],[12,"sum",E,E,6,N],[12,"min",E,E,6,N],[12,"max",E,E,6,N],[12,"mean",E,E,6,N],[12,R[1],E,E,6,N],[12,"var",E,E,6,N],[12,R[2],E,E,6,N],[12,R[3],E,E,6,N],[12,R[4],E,E,6,N],[12,R[5],E,E,6,N],[12,R[6],E,E,6,N],[12,"iqr",E,E,6,N],[5,"winsorize",E,"Winsorize a set of samples, replacing values above the…",N,[[["f64"]]]],[8,"Stats",E,"Trait that provides simple descriptive statistics on a…",N,N],[10,"sum",E,"Sum of the samples.",7,[[["self"]],["f64"]]],[10,"min",E,"Minimum value of the samples.",7,[[["self"]],["f64"]]],[10,"max",E,"Maximum value of the samples.",7,[[["self"]],["f64"]]],[10,"mean",E,"Arithmetic mean (average) of the samples: sum divided by…",7,[[["self"]],["f64"]]],[10,R[1],E,"Median of the samples: value separating the lower half of…",7,[[["self"]],["f64"]]],[10,"var",E,"Variance of the samples: bias-corrected mean of the…",7,[[["self"]],["f64"]]],[10,R[2],E,"Standard deviation: the square root of the sample variance.",7,[[["self"]],["f64"]]],[10,R[3],E,"Standard deviation as a percent of the mean value. See…",7,[[["self"]],["f64"]]],[10,R[4],E,"Scaled median of the absolute deviations of each sample…",7,[[["self"]],["f64"]]],[10,R[5],E,"Median absolute deviation as a percent of the median. See…",7,[[["self"]],["f64"]]],[10,"percentile",E,"Percentile: the value below which `pct` percent of the…",7,[[["f64"],["self"]],["f64"]]],[10,R[6],E,"Quartiles of the sample: three values that divide the…",7,[[["self"]]]],[10,"iqr",E,"Inter-quartile range: the difference between the 25th…",7,[[["self"]],["f64"]]],[11,"new",E,"Construct a new summary of a sample set.",6,[[],[R[9]]]],[0,"bench",R[7],E,N,N],[5,"benchmark","bencher::bench",E,N,[[["f"]],[R[8]]]],[5,"run_once",E,E,N,[[["f"]]]],[6,"TestName",R[7],E,N,N],[8,R[27],E,"Represents a benchmark function.",N,N],[10,"run",E,E,8,[[[R[7]],["self"]]]],[11,"iter",E,"Callback for benchmark functions to run in their body.",0,[[["self"],["f"]]]],[11,"ns_elapsed",E,E,0,[[["self"]],["u64"]]],[11,"ns_per_iter",E,E,0,[[["self"]],["u64"]]],[11,"bench_n",E,E,0,[[["self"],["u64"],["f"]]]],[11,"auto_bench",E,E,0,[[["self"],["f"]],[R[9]]]],[14,"benchmark_group",E,"Defines a function called `$group_name` that returns the…",N,N],[14,"benchmark_main",E,"Define a `fn main()` that will run all benchmarks defined…",N,N],[11,"into",E,E,0,[[],[U]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[10],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"],[T]]]],[11,R[12],E,E,0,[[[U]],[R[14]]]],[11,R[13],E,E,0,[[],[R[14]]]],[11,R[17],E,E,0,[[["self"]],[T]]],[11,R[15],E,E,0,[[["self"]],[T]]],[11,R[16],E,E,0,[[["self"]],[R[18]]]],[11,"into",E,E,1,[[],[U]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[10],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"],[T]]]],[11,R[12],E,E,1,[[[U]],[R[14]]]],[11,R[13],E,E,1,[[],[R[14]]]],[11,R[17],E,E,1,[[["self"]],[T]]],[11,R[15],E,E,1,[[["self"]],[T]]],[11,R[16],E,E,1,[[["self"]],[R[18]]]],[11,"into",E,E,2,[[],[U]]],[11,"from",E,E,2,[[[T]],[T]]],[11,R[10],E,E,2,[[["self"]],[T]]],[11,R[11],E,E,2,[[["self"],[T]]]],[11,R[12],E,E,2,[[[U]],[R[14]]]],[11,R[13],E,E,2,[[],[R[14]]]],[11,R[17],E,E,2,[[["self"]],[T]]],[11,R[15],E,E,2,[[["self"]],[T]]],[11,R[16],E,E,2,[[["self"]],[R[18]]]],[11,"into",E,E,3,[[],[U]]],[11,"from",E,E,3,[[[T]],[T]]],[11,R[12],E,E,3,[[[U]],[R[14]]]],[11,R[13],E,E,3,[[],[R[14]]]],[11,R[17],E,E,3,[[["self"]],[T]]],[11,R[15],E,E,3,[[["self"]],[T]]],[11,R[16],E,E,3,[[["self"]],[R[18]]]],[11,"into",E,E,4,[[],[U]]],[11,"from",E,E,4,[[[T]],[T]]],[11,R[12],E,E,4,[[[U]],[R[14]]]],[11,R[13],E,E,4,[[],[R[14]]]],[11,R[17],E,E,4,[[["self"]],[T]]],[11,R[15],E,E,4,[[["self"]],[T]]],[11,R[16],E,E,4,[[["self"]],[R[18]]]],[11,"into",E,E,9,[[],[U]]],[11,"from",E,E,9,[[[T]],[T]]],[11,R[10],E,E,9,[[["self"]],[T]]],[11,R[11],E,E,9,[[["self"],[T]]]],[11,R[12],E,E,9,[[[U]],[R[14]]]],[11,R[13],E,E,9,[[],[R[14]]]],[11,R[17],E,E,9,[[["self"]],[T]]],[11,R[15],E,E,9,[[["self"]],[T]]],[11,R[16],E,E,9,[[["self"]],[R[18]]]],[11,"into",E,E,5,[[],[U]]],[11,"from",E,E,5,[[[T]],[T]]],[11,R[12],E,E,5,[[[U]],[R[14]]]],[11,R[13],E,E,5,[[],[R[14]]]],[11,R[17],E,E,5,[[["self"]],[T]]],[11,R[15],E,E,5,[[["self"]],[T]]],[11,R[16],E,E,5,[[["self"]],[R[18]]]],[11,"into",R[19],E,6,[[],[U]]],[11,"from",E,E,6,[[[T]],[T]]],[11,R[10],E,E,6,[[["self"]],[T]]],[11,R[11],E,E,6,[[["self"],[T]]]],[11,R[12],E,E,6,[[[U]],[R[14]]]],[11,R[13],E,E,6,[[],[R[14]]]],[11,R[17],E,E,6,[[["self"]],[T]]],[11,R[15],E,E,6,[[["self"]],[T]]],[11,R[16],E,E,6,[[["self"]],[R[18]]]],[11,"clone",E,E,6,[[["self"]],[R[9]]]],[11,"clone",R[7],E,0,[[["self"]],[R[7]]]],[11,"clone",E,E,1,[[["self"]],[R[21]]]],[11,"clone",E,E,2,[[["self"]],["testpaths"]]],[11,"clone",E,E,9,[[["self"]],[R[8]]]],[11,"default",E,E,4,[[],[R[20]]]],[11,"eq",R[19],E,6,[[["self"],[R[9]]],["bool"]]],[11,"ne",E,E,6,[[["self"],[R[9]]],["bool"]]],[11,"eq",R[7],E,1,[[[R[21]],["self"]],["bool"]]],[11,"ne",E,E,1,[[[R[21]],["self"]],["bool"]]],[11,"eq",E,E,9,[[["self"],[R[8]]],["bool"]]],[11,"ne",E,E,9,[[["self"],[R[8]]],["bool"]]],[11,"fmt",E,E,5,[[["self"],[R[22]]],[R[14]]]],[11,"fmt",E,E,1,[[["self"],[R[22]]],[R[14]]]],[11,"fmt",E,E,3,[[["self"],[R[22]]],[R[14]]]],[11,"hash",E,E,1,[[["self"],["__h"]]]]],"p":[[3,"Bencher"],[3,R[23]],[3,R[24]],[3,R[25]],[3,R[26]],[4,"TestFn"],[3,"Summary"],[8,"Stats"],[8,R[27]],[3,R[28]]]};
searchIndex["big_project"]={"doc":E,"i":[[5,"dummy",R[29],E,N,[[],["u8"]]],[5,"generate_invert_ppm_file",E,"Generates a invert image # Arguments * `from` - A string…",N,[[]]],[5,"generate_grayscale_ppm_file",E,"Generates a grayscale image # Arguments * `from` - A…",N,[[]]],[5,"copy_ppm_file",E,"Generate a copy image # Arguments * `from` - A string path…",N,[[]]],[0,"pixel",E,E,N,N],[0,"pixel","big_project::pixel",E,N,N],[3,"Pixel",R[31],E,N,N],[5,R[30],E,"grayscaled pixel",N,[[["pixel"]],["pixel"]]],[11,"new",E,"Constructor Pixel # Arguments * `red` - A u8 (red value of…",0,[[["u8"]],["pixel"]]],[11,"red",E,"Get red to pixel # Return  * red pixel -> u8",0,[[],["u8"]]],[11,"green",E,"Get green to pixel # Return  * green pixel -> u8",0,[[],["u8"]]],[11,"blue",E,"Get blue to pixel # Return  * blue pixel -> u8",0,[[],["u8"]]],[11,"display",E,"Returns a string which describes the pixel # Returns *…",0,[[],["string"]]],[11,"inverse",E,"Reverse pixel values",0,[[["self"]]]],[0,"image",R[29],E,N,N],[0,"image","big_project::image",E,N,N],[3,"Image",R[32],"Image of a RGB image",N,N],[12,"height",E,"height of the image",1,N],[12,"width",E,"width of the image",1,N],[12,"pixel_encoding",E,"max value for a RGB color in pixels ",1,N],[12,"pixels",E,"pixels contained in the image",1,N],[5,"invert",E,"Returns an Image from another image with all reversed…",N,[[["image"]],["image"]]],[5,R[30],E,"Returns an Image from another image with all grayscaled…",N,[[["image"]],["image"]]],[11,"new_with_file",E,"Generates an Image structure from a file path Reads the…",1,[[["path"]],["image"]]],[11,"save",E,"Saves the current image into a new ppm file # Arguments *…",1,[[["path"]],[R[14]]]],[11,"into",R[31],E,0,[[],[U]]],[11,"from",E,E,0,[[[T]],[T]]],[11,R[10],E,E,0,[[["self"]],[T]]],[11,R[11],E,E,0,[[["self"],[T]]]],[11,R[12],E,E,0,[[[U]],[R[14]]]],[11,R[13],E,E,0,[[],[R[14]]]],[11,R[17],E,E,0,[[["self"]],[T]]],[11,R[15],E,E,0,[[["self"]],[T]]],[11,R[16],E,E,0,[[["self"]],[R[18]]]],[11,"into",R[32],E,1,[[],[U]]],[11,"from",E,E,1,[[[T]],[T]]],[11,R[10],E,E,1,[[["self"]],[T]]],[11,R[11],E,E,1,[[["self"],[T]]]],[11,R[12],E,E,1,[[[U]],[R[14]]]],[11,R[13],E,E,1,[[],[R[14]]]],[11,R[17],E,E,1,[[["self"]],[T]]],[11,R[15],E,E,1,[[["self"]],[T]]],[11,R[16],E,E,1,[[["self"]],[R[18]]]],[11,"clone",R[31],E,0,[[["self"]],["pixel"]]],[11,"clone",R[32],E,1,[[["self"]],["image"]]],[11,"eq",R[31],E,0,[[["self"]],["bool"]]]],"p":[[3,"Pixel"],[3,"Image"]]};
initSearch(searchIndex);addSearchOptions(searchIndex);